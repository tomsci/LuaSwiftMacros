# LuaSwiftMacros

This is a companion project to https://github.com/tomsci/LuaSwift/ which uses Swift macros to automate the boilerplate of declaring metatables for swift types that are intended to be Bridged into Lua. See [Bridging a Swift object into Lua](https://tomsci.github.io/LuaSwift/documentation/lua/bridgingswifttolua/) for more details.

Using just LuaSwift, the shortest declaration for a metatable for a given struct would look something like this, using `PushableWithMetatable` and providing a `metatable` definition:

```swift
import Lua

struct Foo : PushableWithMetatable {
    public func hello() -> String { return "world!" }

    static var metatable: Metatable<Foo> { .init(fields: [
        "hello": .memberfn { $0.hello() }
    ])}
}
```

With LuaSwiftMacros all you need to do is decorate the class or struct with the `@Pushable` macro:

```swift
import Lua
import LuaMacros

@Pushable
struct Foo {
    public func hello() -> String { return "world!" }
}
```

The `@Pushable` macro adds conformance to `PushableWithMetatable` and a `metatable` to the struct, which in this case makes the "hello" function callable from Lua.

## Usage/Limitations

* `@Pushable` can only be added to structs and classes, since these are the only types intended to be bridged. 
* By default, all public properties and functions will be added to the metatable. Customize with `@Lua`, see below.
* Both computed and stored member properties are supported. Static stored (`static let foo = ...`) and computed properies (`static var foo { ... }`) are also supported.
* Functions with generic parameters are not supported and will be skipped over.
* It is possible that the `@Pushable` macro will produce something that doesn't compile; please report this if you encounter it.
* Use `@PushableSubclass<ParentType>` to define metatables for subclasses where the parent class already is `Pushable`.

## Controlling field visibility with `@Lua`

By default, all public properties and functions will be added to the metatable. This can be overridden on a per-field basis using the `@Lua` macro.

Use `@Lua(false)` to not add a property/function to the metatable which would otherwise be added:

```swift
@Pushable
struct Foo {
    @Lua(false) // This will mean hello() will not be bridged
    public func hello() -> String { return "world!" }
}
```

Use `@Lua` or `@Lua(true)` to add a property/function to the metatable, regardless of whether it is public: 

```swift
@Pushable
struct Foo {
    @Lua // This will mean hello() will be bridged even though it is private
    private func hello() -> String { return "world!" }
}
```

Use `@Lua(name: "newname")` to change the name that is used in the metatable:

```swift
@Pushable
struct Foo {
    // This will mean _hello() will be callable from Lua as object:hello()
    @Lua(name: "hello")
    private func _hello() -> String { return "world!" }
}
```

## Customizing the metatable

Metafields may be added to the generated metatable, if the autogenerated result is lacking. This is done by 
declaring private vars named `metafield_<name>`, in the declaration the `@Pushable` is attached to. For example, to
add a `close` metamethod, declare a `metafield_close` variable of the type used by `Metatable<T>`'s [constructor](https://tomsci.github.io/LuaSwift/documentation/lua/metatable/init(fields:add:sub:mul:div:mod:pow:unm:idiv:band:bor:bxor:bnot:shl:shr:concat:len:eq:lt:le:index:newindex:call:close:tostring:pairs:name:)):

```swift
@Pushable
class Foo {
    public func close() { print("Closed!") }
    
    private static var metafield_close: Metatable<Foo>.CloseType {
        .memberfn { $0.close() }
    }
}
```

Some protocols, specifically `Equatable` `Comparable` and `Closable`, are automatically added to the metatable if the struct/class conforms to them (as `eq`, `lt`, `le`, and `close` metamethods). Hence the above could have been written:

```swift
@Pushable
class Foo : Closable {
    public func close() { print("Closed!") }
}
```

The macro can only check for direct conformance however, so manually specifying them (with for example `metafield_close: .synthesize`) can be necessary in some contexts. Conversely, if the Swift type conforms to one of those protocols but you _don't_ want the Lua type to automatically synthesize a metafield from it, include a `metafield_x` member with the value `.none`:

```swift
@Pushable
struct Foo : Equatable {
    public let val: Int

    // Override the Equatable and make the Lua type _not_ have an eq metamethod
    private static var metafield_eq: Metatable<Foo>.EqType { .none }
}
```

## Including in your project

To include in your project, use a Package.swift file something like this:

```swift
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "ExampleLuaSwiftProj",
    platforms: [
        .macOS(.v10_15)
    ],
    dependencies: [
        .package(url: "https://github.com/tomsci/LuaSwift.git", branch: "main"),
        .package(url: "https://github.com/tomsci/LuaSwiftMacros.git", branch: "main"),
    ],
    targets: [
        .executableTarget(
            name: "ExampleLuaSwiftProj",
            dependencies: [
                .product(name: "Lua", package: "LuaSwift"),
                .product(name: "LuaMacros", package: "LuaSwiftMacros"),
            ]
        )
    ]
)
```

## API compatibility

The LuaSwiftMacros project is at an early stage and the API may change without warning. At any given time the head of the main branch will be tested with the head of main branch of LuaSwift, and no compatibility beyond that is guaranteed at this point. It is tested with Swift 6.1 only -- earlier versions definitely will not work, later versions may.

## License

LuaSwiftMacros is written and maintained by Tom Sutcliffe and is distributed under the [MIT License](LICENSE).
