// Copyright (c) 2025 Tom Sutcliffe
// See LICENSE file for license information.

// Last tested with: Xcode Version 16.3 (16E140)

import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest

// Macro implementations build for the host, so the corresponding module is not available when cross-compiling. Cross-compiled tests may still make use of the macro itself in end-to-end tests.

// Note(tomsci): I have no explanation for the above (it's a generated comment) but basically the upshot appears to be
// that 'swift test' just doesn't work for a package generated by `swift package init --type macro`. And the internet
// doesn't have a simple explanation of why not. This thread:
// https://forums.swift.org/t/swift-testing-support-for-macros/72720/8 leaves me none the wiser. So for now, this file
// is a big ol no-op when run from anything other than interactively in Xcode. My disappointment is measurable and my
// day was not ruined, but only because I'm accustomed to this kind of crap at this point. Suggestions for fixing this
// welcome.

#if canImport(LuaMacros)
import Lua
import LuaMacros
import LuaMacrosImpl

let testMacros: [String: Macro.Type] = [
    "Pushable": PushableMacro.self,
    "PushableSubclass": PushableMacro.self,
    "PushableEnum": PushableMacro.self,
    "Lua": LuaAttributeMacro.self,
]

final class LuaSwiftMacrosTests: XCTestCase {

    func testLetProperty() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public let member: String
            }
            """,
            expandedSource: #"""
            struct Foo {
                public let member: String

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "member": .property(\.member)
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testVarProperty() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public var member: String
            }
            """,
            expandedSource: #"""
            struct Foo {
                public var member: String

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "member": .property(\.member)
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testBarewordProperty() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public var `public`: String
            }
            """,
            expandedSource: #"""
            struct Foo {
                public var `public`: String

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "public": .property(\.public)
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testGenericProperty() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo<T> {
                public var prop: T
            }
            """,
            expandedSource: #"""
            struct Foo<T> {
                public var prop: T

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "prop": .property(\.prop)
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testStaticLet() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public static let member = "woop"
            }
            """,
            expandedSource: #"""
            struct Foo {
                public static let member = "woop"

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "member": .constant(Foo.member)
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testStaticVar() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public static var member: String { "woop" }
            }
            """,
            expandedSource: #"""
            struct Foo {
                public static var member: String { "woop" }

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "member": .staticvar {
                                    return Foo.member
                                }
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testMemberFn() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public func noargs() -> Bool { return true }
                public func namedArg(arg: Int) { }
                public func anonArg(_ arg: String) -> String { return arg }
                public func mixedArgs(arg1: Int, _ arg2: Int, arg3: Int) { }
            }
            """,
            expandedSource: #"""
            struct Foo {
                public func noargs() -> Bool { return true }
                public func namedArg(arg: Int) { }
                public func anonArg(_ arg: String) -> String { return arg }
                public func mixedArgs(arg1: Int, _ arg2: Int, arg3: Int) { }

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "noargs": .memberfn {
                                    $0.noargs()
                                },
                            "namedArg": .memberfn {
                                    $0.namedArg(arg: $1)
                                },
                            "anonArg": .memberfn {
                                    $0.anonArg($1)
                                },
                            "mixedArgs": .memberfn {
                                    $0.mixedArgs(arg1: $1, $2, arg3: $3)
                                }
                        ])
                }
            }

            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testStaticFn() throws {
        assertMacroExpansion(
            """
            @Pushable struct Foo {
                public static func noargs() -> Bool { return true }
            }
            """,
            expandedSource: #"""
            struct Foo {
                public static func noargs() -> Bool { return true }

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "noargs": .staticfn {
                                    Foo.noargs()
                                }
                        ])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testEquatableAuto() throws {
        assertMacroExpansion(
            """
            @Pushable struct EqThing: Equatable {}
            """,
            expandedSource: #"""
            struct EqThing: Equatable {

                static var metatable: Metatable<EqThing> {
                    .init(fields: [:],
                        eq: .synthesize)
                }
            }

            extension EqThing: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testEquatableNope() throws {
        assertMacroExpansion(
            """
            @Pushable
            struct NotEq: Equatable {
                private static var metafield_eq: Metatable<NotEq>.EqType { .none }
            }
            """,
            expandedSource: #"""
            struct NotEq: Equatable {
                private static var metafield_eq: Metatable<NotEq>.EqType { .none }

                static var metatable: Metatable<NotEq> {
                    .init(fields: [:],
                        eq: metafield_eq)
                }
            }

            extension NotEq: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testHideDecls() throws {
        assertMacroExpansion(
            """
            @Pushable
            struct Foo {
                public var yep: String
                @Lua(false)
                public var nope: String
                public func yepFn() {}
                @Lua(false)
                public func nopeFn() {}
            }
            """,
            expandedSource: #"""
            struct Foo {
                public var yep: String
                public var nope: String
                public func yepFn() {}
                public func nopeFn() {}

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "yep": .property(\.yep),
                            "yepFn": .memberfn {
                                    $0.yepFn()
                                }
                        ])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testRenameDecls() throws {
        assertMacroExpansion(
            """
            @Pushable
            struct Foo {
                public var yep: String
                @Lua(name: "maybe")
                private var nope: String
                public func yepFn() {}
                @Lua(name: "maybeFn")
                private func nopeFn() {}
            }
            """,
            expandedSource: #"""
            struct Foo {
                public var yep: String
                private var nope: String
                public func yepFn() {}
                private func nopeFn() {}

                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "yep": .property(\.yep),
                            "maybe": .property(\.nope),
                            "yepFn": .memberfn {
                                    $0.yepFn()
                                },
                            "maybeFn": .memberfn {
                                    $0.nopeFn()
                                }
                        ])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testSubclass() throws {
        assertMacroExpansion(
            """
            @PushableSubclass<BaseClass>
            class DerivedClass: BaseClass {
                override func test() -> String {
                    return "Derived"
                }
            
                public func derivedfn() {}
            }
            """,
            expandedSource: #"""
            class DerivedClass: BaseClass {
                override func test() -> String {
                    return "Derived"
                }
            
                public func derivedfn() {}
            
                class override var metatable: Metatable<BaseClass> {
                    BaseClass.metatable.subclass(type: DerivedClass.self, fields: [
                            "derivedfn": .memberfn {
                                    $0.derivedfn()
                                }
                        ])
                }
            }
            """#,
            macros: testMacros)
    }

    func testEnum() throws {
        assertMacroExpansion(
            """
            @Pushable
            enum Foo {
                case foo
                case bar
            }
            """,
            expandedSource: #"""
            enum Foo {
                case foo
                case bar
            
                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "type": .property(get: {
                                        switch $0 {
                                        case .foo:
                                            return "foo"
                                        case .bar:
                                            return "bar"
                                        }
                                    })
                        ])
                }
            
                static var metaobject: Metaobject<Foo> {
                    .init(metatable: Foo.metatable, fields: [
                            "foo": .staticvar {
                                    return Foo.foo
                                },
                            "bar": .staticvar {
                                    return Foo.bar
                                }])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testEnumRenameType() throws {
        assertMacroExpansion(
            """
            @PushableEnum(typeName: "_type")
            enum Foo {
                case foo
                case bar
            }
            """,
            expandedSource: #"""
            enum Foo {
                case foo
                case bar
            
                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "_type": .property(get: {
                                        switch $0 {
                                        case .foo:
                                            return "foo"
                                        case .bar:
                                            return "bar"
                                        }
                                    })
                        ])
                }
            
                static var metaobject: Metaobject<Foo> {
                    .init(metatable: Foo.metatable, fields: [
                            "foo": .staticvar {
                                    return Foo.foo
                                },
                            "bar": .staticvar {
                                    return Foo.bar
                                }])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testEnumNoType() throws {
        assertMacroExpansion(
            """
            @PushableEnum(typeName: nil)
            enum Foo: Equatable {
                case foo
                case bar
            }
            """,
            expandedSource: #"""
            enum Foo: Equatable {
                case foo
                case bar
            
                static var metatable: Metatable<Foo> {
                    .init(fields: [:],
                        eq: .synthesize)
                }
            
                static var metaobject: Metaobject<Foo> {
                    .init(metatable: Foo.metatable, fields: [
                            "foo": .staticvar {
                                    return Foo.foo
                                },
                            "bar": .staticvar {
                                    return Foo.bar
                                }])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testEnumAssociatedValues() throws {
        assertMacroExpansion(
            """
            @Pushable
            enum Foo {
                case foo
                case bar(Int)
                case baz(String, Int)
                @Lua(name: "batval") case bat(Int)
                @Lua(name: "borpstr", "borpint")
                case borp(String, Int)
            }
            """,
            expandedSource: #"""
            enum Foo {
                case foo
                case bar(Int)
                case baz(String, Int)
                case bat(Int)
                case borp(String, Int)
            
                static var metatable: Metatable<Foo> {
                    .init(fields: [
                            "bar_value": .property(get: { obj -> Optional<Int> in
                                        if case .bar(let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "baz_1": .property(get: { obj -> Optional<String> in
                                        if case .baz(let value, _) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "baz_2": .property(get: { obj -> Optional<Int> in
                                        if case .baz(_, let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "batval": .property(get: { obj -> Optional<Int> in
                                        if case .bat(let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "borpstr": .property(get: { obj -> Optional<String> in
                                        if case .borp(let value, _) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "borpint": .property(get: { obj -> Optional<Int> in
                                        if case .borp(_, let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "type": .property(get: {
                                        switch $0 {
                                        case .foo:
                                            return "foo"
                                        case .bar(_):
                                            return "bar"
                                        case .baz(_, _):
                                            return "baz"
                                        case .bat(_):
                                            return "bat"
                                        case .borp(_, _):
                                            return "borp"
                                        }
                                    })
                        ])
                }
            
                static var metaobject: Metaobject<Foo> {
                    .init(metatable: Foo.metatable, fields: [
                            "foo": .staticvar {
                                    return Foo.foo
                                },
                            "bar": .staticfn {
                                    return Foo.bar($0)
                                },
                            "baz": .staticfn {
                                    return Foo.baz($0, $1)
                                },
                            "bat": .staticfn {
                                    return Foo.bat($0)
                                },
                            "borp": .staticfn {
                                    return Foo.borp($0, $1)
                                }])
                }
            }
            
            extension Foo: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }

    func testNamedTupleEnum() {
        assertMacroExpansion(
            """
            @Pushable
            enum NamedTupleEnum: Equatable {
                case foo(someint: Int)
                case bar(barstr: String, bval: Int)
            }
            """,
            expandedSource: #"""
            enum NamedTupleEnum: Equatable {
                case foo(someint: Int)
                case bar(barstr: String, bval: Int)

                static var metatable: Metatable<NamedTupleEnum> {
                    .init(fields: [
                            "someint": .property(get: { obj -> Optional<Int> in
                                        if case .foo(let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "barstr": .property(get: { obj -> Optional<String> in
                                        if case .bar(let value, _) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "bval": .property(get: { obj -> Optional<Int> in
                                        if case .bar(_, let value) = obj {
                                            return value
                                        } else {
                                            return nil
                                        }
                                    }),
                            "type": .property(get: {
                                        switch $0 {
                                        case .foo(_):
                                            return "foo"
                                        case .bar(_, _):
                                            return "bar"
                                        }
                                    })
                        ],
                        eq: .synthesize)
                }

                static var metaobject: Metaobject<NamedTupleEnum> {
                    .init(metatable: NamedTupleEnum.metatable, fields: [
                            "foo": .staticfn {
                                    return NamedTupleEnum.foo(someint: $0)
                                },
                            "bar": .staticfn {
                                    return NamedTupleEnum.bar(barstr: $0, bval: $1)
                                }])
                }
            }
            
            extension NamedTupleEnum: PushableWithMetatable {
            }
            """#,
            macros: testMacros)
    }
}

#endif
